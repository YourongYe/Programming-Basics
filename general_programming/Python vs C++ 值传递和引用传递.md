 # Example First
 
```py
a = 12
b = a
print(a is b) # 这里实际上b=a应该属于值传递，但是由于python为了提高性能，会自动缓存[-5, 256]区间的数字，所以此处a和b指向同一个地址
print(id(a), id(b)) # 只有重新创建的variable才会有不同的id，可以推测出，存在cache上的值如果相同，则id相同
a += 10
print(a,b) # b没有随a改变，因为数字属于不可变对象，所以python默认应该是值传递

# 以下为list的例子
c = [1,2,3,4]
d = c
d[0] = 200
print(c)
```

# Result
```py
True
4455872192 4455872192 # a和b会share同一个ID是一种特殊情况，python是oo language，一般来讲，每个object都有自己的id
22 12 #此后他们不会再share id，但如果在同一个run time中，我们又新建一个h=22，那么h和a的id也会相同

[200, 2, 3, 4]
```

# 结论1
python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。  
如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。  
如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值'来传递对象   
 
## 和C++比较
C++里如果没有明确选择引用传递，用pointer或者reference，则任何数据结构都默认是值传递

# 结论2
python中id相同的情况不多，需三个条件：  
1.[-5, 256]区间的数字   
2. assignment发生在同一个run time（如果分开run也会id不同）  
3. 必须在同一个模块（block）中，比如在functio 中新建一个x，即使满足上面两个条件，也不会是同样的id


